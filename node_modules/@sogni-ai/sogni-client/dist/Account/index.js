"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ApiGroup_1 = __importDefault(require("../ApiGroup"));
const ethers_1 = require("ethers");
const ApiClient_1 = require("../ApiClient");
const CurrentAccount_1 = __importDefault(require("./CurrentAccount"));
const utils_1 = require("../lib/utils");
const MAX_DEPOSIT_ATTEMPTS = 4;
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["INSUFFICIENT_BALANCE"] = 123] = "INSUFFICIENT_BALANCE";
    ErrorCode[ErrorCode["INSUFFICIENT_ALLOWANCE"] = 149] = "INSUFFICIENT_ALLOWANCE";
})(ErrorCode || (ErrorCode = {}));
/**
 * Account API methods that let you interact with the user's account.
 * Can be accessed via `client.account`. Look for more samples below.
 *
 * @example Retrieve the current account balance
 * ```typescript
 * const balance = await client.account.refreshBalance();
 * console.log(balance);
 * ```
 *
 */
class AccountApi extends ApiGroup_1.default {
    constructor(config) {
        super(config);
        this.currentAccount = new CurrentAccount_1.default();
        this.client.socket.on('balanceUpdate', this.handleBalanceUpdate.bind(this));
        this.client.on('connected', this.handleServerConnected.bind(this));
        this.client.on('disconnected', this.handleServerDisconnected.bind(this));
        this.client.auth.on('updated', this.handleAuthUpdated.bind(this));
    }
    handleBalanceUpdate(data) {
        this.currentAccount._update({ balance: data });
    }
    handleServerConnected({ network }) {
        this.currentAccount._update({
            networkStatus: 'connected',
            network
        });
    }
    handleServerDisconnected() {
        this.currentAccount._clear();
    }
    handleAuthUpdated({ refreshToken, token, walletAddress }) {
        if (!refreshToken) {
            this.currentAccount._clear();
        }
        else {
            this.currentAccount._update({ walletAddress, token, refreshToken });
        }
    }
    /**
     * Get the nonce for the given wallet address.
     * @param walletAddress
     * @internal
     */
    getNonce(walletAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.client.rest.post('/v1/account/nonce', {
                walletAddress
            });
            return res.data.nonce;
        });
    }
    /**
     * Create Ethers.js Wallet instance from username and password.
     * This method is used internally to create a wallet for the user.
     * You can use this method to create a wallet if you need to sign transactions.
     *
     * @example Create a wallet from username and password
     * ```typescript
     * const wallet = client.account.getWallet('username', 'password');
     * console.log(wallet.address);
     * ```
     *
     * @param username - Sogni account username
     * @param password - Sogni account password
     */
    getWallet(username, password) {
        const pwd = (0, ethers_1.toUtf8Bytes)(username.toLowerCase() + password);
        const salt = (0, ethers_1.toUtf8Bytes)('sogni-salt-value');
        const pkey = (0, ethers_1.pbkdf2)(pwd, salt, 10000, 32, 'sha256');
        return new ethers_1.Wallet(pkey);
    }
    /**
     * Create a new account with the given username, email, and password.
     * @internal
     */
    create(_a) {
        return __awaiter(this, arguments, void 0, function* ({ username, email, password, subscribe, turnstileToken, referralCode }) {
            const wallet = this.getWallet(username, password);
            const nonce = yield this.getNonce(wallet.address);
            const payload = {
                appid: this.client.appId,
                username,
                email,
                subscribe: subscribe ? 1 : 0,
                walletAddress: wallet.address,
                turnstileToken
            };
            const signature = yield this.eip712.signTypedData(wallet, 'signup', Object.assign(Object.assign({}, payload), { nonce }));
            const res = yield this.client.rest.post('/v1/account/create', Object.assign(Object.assign({}, payload), { referralCode,
                signature }));
            yield this.setToken(username, { refreshToken: res.data.refreshToken, token: res.data.token });
            return res.data;
        });
    }
    /**
     * Restore session with username and refresh token.
     *
     * You can save access token that you get from the login method and restore the session with this method.
     *
     * @example Store access token to local storage
     * ```typescript
     * const { username, token, refreshToken } = await client.account.login('username', 'password');
     * localStorage.setItem('sogni-username', username);
     * localStorage.setItem('sogni-token', token);
     * localStorage.setItem('sogni-refresh-token', refreshToken);
     * ```
     *
     * @example Restore session from local storage
     * ```typescript
     * const username = localStorage.getItem('sogni-username');
     * const token = localStorage.getItem('sogni-token');
     * const refreshToken = localStorage.getItem('sogni-refresh-token');
     * if (username && refreshToken) {
     *  client.account.setToken(username, {token, refreshToken});
     *  console.log('Session restored');
     * }
     * ```
     *
     * @param username
     * @param tokens - Refresh token, access token pair { refreshToken: string, token: string }
     */
    setToken(username, tokens) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.authenticate(tokens);
            this.currentAccount._update({
                username,
                walletAddress: this.client.auth.walletAddress
            });
        });
    }
    /**
     * Login with username and password. WebSocket connection is established after successful login.
     *
     * @example Login with username and password
     * ```typescript
     * await client.account.login('username', 'password');
     * console.log('Logged in');
     * ```
     *
     * @param username
     * @param password
     */
    login(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.getWallet(username, password);
            const nonce = yield this.getNonce(wallet.address);
            const signature = yield this.eip712.signTypedData(wallet, 'authentication', {
                walletAddress: wallet.address,
                nonce
            });
            const res = yield this.client.rest.post('/v1/account/login', {
                walletAddress: wallet.address,
                signature
            });
            yield this.setToken(username, { refreshToken: res.data.refreshToken, token: res.data.token });
            return res.data;
        });
    }
    /**
     * Logout the user and close the WebSocket connection.
     *
     * @example Logout the user
     * ```typescript
     * await client.account.logout();
     * console.log('Logged out');
     * ```
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            this.client.rest.post('/v1/account/logout').catch((e) => {
                this.client.logger.error('Failed to logout', e);
            });
            this.client.removeAuth();
            this.currentAccount._clear();
        });
    }
    /**
     * Refresh the balance of the current account.
     *
     * Usually, you don't need to call this method manually. Balance is updated automatically
     * through WebSocket events. But you can call this method to force a balance refresh. Note that
     * will also trigger updated event on the current account.
     *
     * @example Refresh user account balance
     * ```typescript
     * const balance = await client.account.refreshBalance();
     * console.log(balance);
     * ```
     */
    refreshBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield this.accountBalance();
            this.currentAccount._update({ balance: balance });
            return balance;
        });
    }
    /**
     * Get the account balance of the current account.
     * This method returns the account balance of the current user, including settled, credit, debit, and unclaimed earnings amounts.
     *
     * @example Get the account balance of the current user
     * ```typescript
     * const balance = await client.account.accountBalance();
     * console.log(balance);
     * ```
     */
    accountBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.client.rest.get('/v3/account/balance');
            return res.data;
        });
    }
    /**
     * Get the balance of the wallet address.
     *
     * This method is used to get the balance of the wallet address. It returns $SOGNI and ETH balance.
     *
     * @example Get the balance of the wallet address
     * ```typescript
     * const address = client.account.currentAccount.walletAddress;
     * const balance = await client.account.walletBalance(address);
     * console.log(balance);
     * // { token: '100.000000', ether: '0.000000' }
     * ```
     *
     * @param walletAddress
     */
    walletBalance(walletAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.client.rest.get('/v2/wallet/balance', {
                walletAddress
            });
            return res.data;
        });
    }
    /**
     * Validate the username before signup
     * @internal
     * @param username
     */
    validateUsername(username) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.rest.post('/v1/account/username/validate', {
                    username
                });
            }
            catch (e) {
                if (e instanceof ApiClient_1.ApiError) {
                    // Username is already taken
                    if (e.payload.errorCode === 108) {
                        return e.payload;
                    }
                }
                throw e;
            }
        });
    }
    /**
     * Switch between fast and relaxed networks.
     * This will change default network used to process projects. After switching, client will receive
     * list of AI models available for on selected network.
     *
     * @example Switch to the fast network
     * ```typescript
     * await client.account.switchNetwork('fast');
     * console.log('Switched to the fast network, now lets wait until we get list of models');
     * await client.projects.waitForModels();
     * ```
     * @param network - Network type to switch to
     */
    switchNetwork(network) {
        return __awaiter(this, void 0, void 0, function* () {
            this.currentAccount._update({
                networkStatus: 'switching',
                network: null
            });
            const newNetwork = yield this.client.socket.switchNetwork(network);
            this.currentAccount._update({
                networkStatus: 'connected',
                network: newNetwork
            });
            return newNetwork;
        });
    }
    /**
     * Get the transaction history of the current account.
     *
     * @example Get the transaction history
     * ```typescript
     * const { entries, next } = await client.account.transactionHistory({
     *  status: 'completed',
     *  limit: 10,
     *  address: client.account.currentAccount.walletAddress
     * });
     * ```
     *
     * @param params - Transaction history query parameters
     * @returns Transaction history entries and next query parameters
     */
    transactionHistory(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = {
                status: params.status,
                address: params.address,
                limit: params.limit.toString()
            };
            if (params.offset) {
                query.offset = params.offset.toString();
            }
            if (params.provider) {
                query.provider = params.provider;
            }
            const res = yield this.client.rest.get('/v1/transactions/list', query);
            return {
                entries: res.data.transactions.map((tx) => ({
                    id: tx.id,
                    address: tx.address,
                    createTime: new Date(tx.createTime),
                    updateTime: new Date(tx.updateTime),
                    status: tx.status,
                    role: tx.role,
                    amount: tx.amount,
                    tokenType: tx.tokenType,
                    description: tx.description,
                    source: tx.source,
                    endTime: new Date(tx.endTime),
                    type: tx.type
                })),
                next: Object.assign(Object.assign({}, params), { offset: res.data.next })
            };
        });
    }
    /**
     * Get the rewards of the current account.
     * @internal
     */
    rewards() {
        return __awaiter(this, arguments, void 0, function* (query = {}) {
            const r = yield this.client.rest.get('/v4/account/rewards', query);
            return r.data.rewards.map((raw) => ({
                id: raw.id,
                type: raw.type,
                title: raw.title,
                description: raw.description,
                amount: raw.amount,
                tokenType: raw.tokenType,
                claimed: !!raw.claimed,
                canClaim: !!raw.canClaim,
                lastClaim: new Date(raw.lastClaimTimestamp * 1000),
                provider: query.provider || 'base',
                nextClaim: raw.lastClaimTimestamp && raw.claimResetFrequencySec > -1
                    ? new Date(raw.lastClaimTimestamp * 1000 + raw.claimResetFrequencySec * 1000)
                    : null
            }));
        });
    }
    /**
     * Claim rewards by reward IDs.
     * @internal
     * @param rewardIds
     * @param options - Options for claiming rewards
     * @param options.turnstileToken - Turnstile token for anti-bot protection
     * @param options.provider - Provider name for the rewards
     */
    claimRewards(rewardIds_1) {
        return __awaiter(this, arguments, void 0, function* (rewardIds, { turnstileToken, provider } = {}) {
            const payload = {
                claims: rewardIds,
                provider: provider || 'base'
            };
            if (turnstileToken) {
                payload.turnstileToken = turnstileToken;
            }
            yield this.client.rest.post('/v3/account/reward/claim', payload);
        });
    }
    /**
     * Withdraw funds from the current account to wallet.
     * @example withdraw to current wallet address
     * ```typescript
     * await client.account.withdraw('your-account-password', 100);
     * ```
     *
     * @param password - account password
     * @param amount - amount of tokens to withdraw from account to wallet
     */
    withdraw(password, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.getWallet(this.currentAccount.username, password);
            const walletAddress = wallet.address;
            const nonce = yield this.getNonce(walletAddress);
            const payload = {
                walletAddress: walletAddress,
                amount: (0, ethers_1.parseEther)(amount.toString()).toString()
            };
            if (walletAddress !== this.currentAccount.walletAddress) {
                throw new ApiClient_1.ApiError(400, {
                    status: 'error',
                    message: 'Incorrect password',
                    errorCode: 0
                });
            }
            const signature = yield this.eip712.signTypedData(wallet, 'withdraw', Object.assign(Object.assign({}, payload), { nonce }));
            yield this.client.rest.post('/v1/account/token/withdraw', Object.assign(Object.assign({}, payload), { signature: signature }));
        });
    }
    /**
     * Deposit tokens from wallet to account
     * @example withdraw to current wallet address
     * ```typescript
     * await client.account.deposit('your-account-password', 100);
     * ```
     *
     * @param password - account password
     * @param amount - amount to transfer
     */
    deposit(password, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._deposit(password, amount, 1);
        });
    }
    _deposit(password_1, amount_1) {
        return __awaiter(this, arguments, void 0, function* (password, amount, attemptCount = 1) {
            const wallet = this.getWallet(this.currentAccount.username, password);
            if (wallet.address !== this.currentAccount.walletAddress) {
                throw new ApiClient_1.ApiError(400, {
                    status: 'error',
                    message: 'Incorrect password',
                    errorCode: 0
                });
            }
            try {
                yield this.client.rest.post('/v3/account/token/deposit', {
                    walletAddress: wallet.address,
                    amount: (0, ethers_1.parseEther)(amount.toString()).toString(),
                    provider: 'base'
                });
            }
            catch (error) {
                if (error instanceof ApiClient_1.ApiError) {
                    if (error.payload.errorCode === ErrorCode.INSUFFICIENT_ALLOWANCE) {
                        // If this is the first attempt, we need to approve the token usage,
                        // otherwise we can retry the deposit directly.
                        if (attemptCount === 1) {
                            yield this.approveTokenUsage(password, 'account');
                        }
                        if (attemptCount >= MAX_DEPOSIT_ATTEMPTS) {
                            throw error;
                        }
                        yield (0, utils_1.delay)(10000); // Wait for the approval transaction to be processed
                        yield this._deposit(password, amount, attemptCount + 1);
                        return;
                    }
                    throw error;
                }
                throw error;
            }
        });
    }
    /**
     * Approve SOGNI token usage for the specified spender.
     * @internal
     *
     * @param password - user account password
     * @param spender - Spender type, either 'account' for deposit or 'staker' for staking contract
     * @param provider - Provider name, defaults to 'base', can be 'base', 'etherlink', etc.
     */
    approveTokenUsage(password_1, spender_1) {
        return __awaiter(this, arguments, void 0, function* (password, spender, provider = 'base') {
            const wallet = this.getWallet(this.currentAccount.username, password);
            const permitR = yield this.client.rest.post('/v1/contract/token/approve/permit', {
                walletAddress: wallet.address,
                spender: spender,
                provider: provider
            });
            const { domain, types, message } = permitR.data;
            const signature = yield wallet.signTypedData(domain, types, message);
            yield this.client.rest.post('/v1/contract/token/approve', {
                walletAddress: wallet.address,
                spender: spender,
                provider: provider,
                deadline: message.deadline,
                approveSignature: signature
            });
        });
    }
}
exports.default = AccountApi;
//# sourceMappingURL=index.js.map