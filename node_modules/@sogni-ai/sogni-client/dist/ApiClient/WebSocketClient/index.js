"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RestClient_1 = __importDefault(require("../../lib/RestClient"));
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const base64_1 = require("../../lib/base64");
const isNodejs_1 = __importDefault(require("../../lib/isNodejs"));
const version_1 = require("../../version");
const PROTOCOL_VERSION = '3.0.0';
const PING_INTERVAL = 15000;
class WebSocketClient extends RestClient_1.default {
    constructor(baseUrl, auth, appId, supernetType, logger) {
        const _baseUrl = new URL(baseUrl);
        switch (_baseUrl.protocol) {
            case 'http:':
            case 'ws:':
                _baseUrl.protocol = 'http:';
                break;
            case 'https:':
            case 'wss:':
                _baseUrl.protocol = 'https:';
                break;
            default:
                _baseUrl.protocol = 'https:';
        }
        super(_baseUrl.toString(), auth, logger);
        this.socket = null;
        this._pingInterval = null;
        this.appId = appId;
        this.baseUrl = _baseUrl.toString();
        this._supernetType = supernetType;
    }
    get supernetType() {
        return this._supernetType;
    }
    get isConnected() {
        return !!this.socket;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.socket) {
                this.disconnect();
            }
            const userAgent = `Sogni/${PROTOCOL_VERSION} (sogni-client) ${version_1.LIB_VERSION}`;
            const url = new URL(this.baseUrl);
            const isNotSecure = url.protocol === 'http:' || url.protocol === 'ws:';
            url.protocol = isNotSecure ? 'ws:' : 'wss:';
            url.searchParams.set('appId', this.appId);
            url.searchParams.set('clientName', userAgent);
            url.searchParams.set('clientType', 'artist');
            //At this point 'relaxed' does not work as expected, so we use 'fast' or empty
            url.searchParams.set('forceWorkerId', this._supernetType === 'fast' ? 'fast' : '');
            let params;
            // In Node.js, ws package is used, so we need to set the auth header
            if (isNodejs_1.default) {
                params = {
                    headers: {
                        Authorization: yield this.auth.getToken(),
                        'User-Agent': userAgent
                    }
                };
            }
            this.socket = new isomorphic_ws_1.default(url.toString(), params);
            this.socket.onerror = this.handleError.bind(this);
            this.socket.onmessage = this.handleMessage.bind(this);
            this.socket.onopen = this.handleOpen.bind(this);
            this.socket.onclose = this.handleClose.bind(this);
            this.startPing(this.socket);
        });
    }
    disconnect() {
        if (!this.socket) {
            return;
        }
        const socket = this.socket;
        this.socket = null;
        socket.onerror = null;
        socket.onmessage = null;
        socket.onopen = null;
        this.stopPing();
        socket.close();
    }
    startPing(socket) {
        if (!isNodejs_1.default) {
            return;
        }
        this._pingInterval = setInterval(() => {
            socket.ping();
        }, PING_INTERVAL);
    }
    stopPing() {
        if (this._pingInterval) {
            clearInterval(this._pingInterval);
            this._pingInterval = null;
        }
    }
    switchNetwork(supernetType) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.once('changeNetwork', ({ network }) => {
                this._supernetType = network;
                resolve(network);
            });
            yield this.send('changeNetwork', supernetType);
        }));
    }
    /**
     * Ensure the WebSocket connection is open, waiting if necessary and throwing an error if it fails
     * @private
     */
    waitForConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!this.socket) {
                throw new Error('WebSocket not connected');
            }
            if (this.socket.readyState === isomorphic_ws_1.default.OPEN) {
                return;
            }
            let attempts = 10;
            while (((_a = this.socket) === null || _a === void 0 ? void 0 : _a.readyState) === isomorphic_ws_1.default.CONNECTING) {
                this._logger.info('Waiting for WebSocket connection...');
                yield new Promise((resolve) => setTimeout(resolve, 1000));
                attempts--;
                if (attempts === 0) {
                    this.disconnect();
                    throw new Error('WebSocket connection timeout');
                }
            }
            //@ts-expect-error State may change between checks
            if (((_b = this.socket) === null || _b === void 0 ? void 0 : _b.readyState) !== isomorphic_ws_1.default.OPEN) {
                this.disconnect();
                throw new Error('WebSocket connection failed');
            }
        });
    }
    handleOpen() {
        this.emit('connected', { network: this._supernetType });
    }
    handleClose(e) {
        if (e.target === this.socket) {
            this._logger.info('WebSocket disconnected, cleanup', e);
            this.disconnect();
            this.emit('disconnected', {
                code: e.code,
                reason: e.reason
            });
        }
    }
    handleError(e) {
        this._logger.error('WebSocket error:', e);
    }
    handleMessage(e) {
        let dataPromise;
        // In Node.js, e.data is a Buffer, while in browser it's a Blob
        if (isNodejs_1.default) {
            dataPromise = Promise.resolve(e.data.toString());
        }
        else {
            const data = e.data;
            dataPromise = data.text();
        }
        dataPromise
            .then((str) => {
            const data = JSON.parse(str);
            let payload = null;
            if (data.data) {
                payload = JSON.parse((0, base64_1.base64Decode)(data.data));
            }
            // Convert jobID and imgID to uppercase for consistency
            ['jobID', 'imgID'].forEach((idKey) => {
                if (payload[idKey]) {
                    payload[idKey] = payload[idKey].toUpperCase();
                }
            });
            this._logger.debug('WebSocket:', data.type, payload);
            this.emit(data.type, payload);
        })
            .catch((err) => {
            this._logger.error('Failed to parse WebSocket message:', err);
        });
    }
    send(messageType, data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.waitForConnection();
            this._logger.debug('WebSocket send:', messageType, data);
            this.socket.send(JSON.stringify({ type: messageType, data: (0, base64_1.base64Encode)(JSON.stringify(data)) }));
        });
    }
}
exports.default = WebSocketClient;
//# sourceMappingURL=index.js.map