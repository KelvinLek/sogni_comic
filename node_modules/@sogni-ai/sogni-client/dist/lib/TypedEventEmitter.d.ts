export interface EventMap {
    [event: string]: any;
}
/**
 * @inline
 */
export type EventListener<D> = (data: D) => void;
declare abstract class TypedEventEmitter<E extends EventMap> {
    protected listeners: {
        [K in keyof E]?: EventListener<E[K]>[];
    };
    /**
     * Add an event listener, returns a function that can be called to remove the listener
     * @param event
     * @param listener
     */
    on<T extends keyof E>(event: T, listener: EventListener<E[T]>): () => void;
    /**
     * Add an event listener that will be called only once
     * @param event
     * @param listener
     */
    once<T extends keyof E>(event: T, listener: EventListener<E[T]>): () => void;
    /**
     * Remove an event listener
     * @param event
     * @param listener
     */
    off<T extends keyof E>(event: T, listener: EventListener<E[T]>): void;
    /**
     * Dispatch an event to all listeners
     * @param event
     * @param data
     */
    protected emit<T extends keyof E>(event: T, data: E[T]): void;
}
export default TypedEventEmitter;
