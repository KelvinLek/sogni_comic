"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiError = void 0;
const RestClient_1 = __importDefault(require("../lib/RestClient"));
const WebSocketClient_1 = __importDefault(require("./WebSocketClient"));
const TypedEventEmitter_1 = __importDefault(require("../lib/TypedEventEmitter"));
const ErrorCode_1 = require("./WebSocketClient/ErrorCode");
const AuthManager_1 = __importDefault(require("../lib/AuthManager"));
const WS_RECONNECT_ATTEMPTS = 5;
class ApiError extends Error {
    constructor(status, payload) {
        super(payload.message);
        this.status = status;
        this.payload = payload;
    }
}
exports.ApiError = ApiError;
class ApiClient extends TypedEventEmitter_1.default {
    constructor(baseUrl, socketUrl, appId, networkType, logger, disableSocket = false) {
        super();
        this._reconnectAttempts = WS_RECONNECT_ATTEMPTS;
        this._disableSocket = false;
        this.appId = appId;
        this.logger = logger;
        this._auth = new AuthManager_1.default(baseUrl, logger);
        this._rest = new RestClient_1.default(baseUrl, this._auth, logger);
        this._socket = new WebSocketClient_1.default(socketUrl, this._auth, appId, networkType, logger);
        this._disableSocket = disableSocket;
        this._auth.on('refreshFailed', this.handleRefreshFailed.bind(this));
        this._socket.on('connected', this.handleSocketConnect.bind(this));
        this._socket.on('disconnected', this.handleSocketDisconnect.bind(this));
    }
    get isAuthenticated() {
        return this.auth.isAuthenticated;
    }
    get auth() {
        return this._auth;
    }
    get socket() {
        return this._socket;
    }
    get rest() {
        return this._rest;
    }
    get socketEnabled() {
        return !this._disableSocket;
    }
    authenticate(tokens) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.auth.setTokens(tokens);
            if (!this._disableSocket) {
                yield this.socket.connect();
            }
        });
    }
    removeAuth() {
        this.auth.clear();
        if (this.socket.isConnected) {
            this.socket.disconnect();
        }
    }
    handleSocketConnect({ network }) {
        this._reconnectAttempts = WS_RECONNECT_ATTEMPTS;
        this.emit('connected', { network });
    }
    handleSocketDisconnect(data) {
        if (!data.code || (0, ErrorCode_1.isNotRecoverable)(data.code)) {
            this.removeAuth();
            this.emit('disconnected', data);
            this.logger.error('Not recoverable socket error', data);
            return;
        }
        if (this._reconnectAttempts <= 0) {
            this.removeAuth();
            this.emit('disconnected', data);
            this._reconnectAttempts = WS_RECONNECT_ATTEMPTS;
            return;
        }
        this._reconnectAttempts--;
        setTimeout(() => this.socket.connect(), 1000);
    }
    handleRefreshFailed() {
        this.removeAuth();
    }
}
exports.default = ApiClient;
//# sourceMappingURL=index.js.map