"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.enhancementDefaults = void 0;
const DataEntity_1 = __importDefault(require("../lib/DataEntity"));
const getUUID_1 = __importDefault(require("../lib/getUUID"));
const utils_1 = require("./utils");
exports.enhancementDefaults = {
    network: 'fast',
    modelId: 'flux1-schnell-fp8',
    positivePrompt: '',
    negativePrompt: '',
    stylePrompt: '',
    startingImageStrength: 0.5,
    steps: 5,
    guidance: 1,
    numberOfImages: 1,
    numberOfPreviews: 0
};
const JOB_STATUS_MAP = {
    created: 'pending',
    queued: 'pending',
    assigned: 'initiating',
    initiatingModel: 'initiating',
    jobStarted: 'processing',
    jobProgress: 'processing',
    jobCompleted: 'completed',
    jobError: 'failed'
};
class Job extends DataEntity_1.default {
    static fromRaw(rawProject, rawJob, options) {
        return new Job({
            id: rawJob.imgID || (0, getUUID_1.default)(),
            projectId: rawProject.id,
            status: JOB_STATUS_MAP[rawJob.status],
            step: rawJob.performedSteps,
            stepCount: rawProject.stepCount,
            workerName: rawJob.worker.name,
            seed: rawJob.seedUsed,
            isNSFW: rawJob.triggeredNSFWFilter
        }, options);
    }
    constructor(data, options) {
        super(data);
        this._enhancementProject = null;
        this._api = options.api;
        this._logger = options.logger;
        this._project = options.project;
        this.on('updated', this.handleUpdated.bind(this));
        this.handleEnhancementUpdate = this.handleEnhancementUpdate.bind(this);
    }
    get id() {
        return this.data.id;
    }
    get projectId() {
        return this.data.projectId;
    }
    /**
     * Current status of the job.
     */
    get status() {
        return this.data.status;
    }
    get finished() {
        return ['completed', 'failed', 'canceled'].includes(this.status);
    }
    /**
     * Progress of the job in percentage (0-100).
     */
    get progress() {
        return Math.round((this.data.step / this.data.stepCount) * 100);
    }
    /**
     * Current step of the job.
     */
    get step() {
        return this.data.step;
    }
    /**
     * Total number of steps that worker will perform.
     */
    get stepCount() {
        return this.data.stepCount;
    }
    /**
     * Seed used to generate the image. This property is only available when the job is completed.
     */
    get seed() {
        return this.data.seed;
    }
    /**
     * Last preview image URL generated by the worker.
     */
    get previewUrl() {
        return this.data.previewUrl;
    }
    /**
     * URL to the result image, could be null if the job was canceled or triggered NSFW filter while
     * it was not disabled explicitly.
     */
    get resultUrl() {
        return this.data.resultUrl;
    }
    get imageUrl() {
        return this.data.resultUrl || this.data.previewUrl;
    }
    get error() {
        return this.data.error;
    }
    get hasResultImage() {
        return this.status === 'completed' && !this.isNSFW;
    }
    get enhancedImage() {
        if (!this._enhancementProject) {
            return null;
        }
        const project = this._enhancementProject;
        const job = project.jobs[0];
        return {
            status: project.status,
            progress: project.progress,
            result: (job === null || job === void 0 ? void 0 : job.resultUrl) || null,
            error: project.error,
            getResultUrl: () => job === null || job === void 0 ? void 0 : job.getResultUrl()
        };
    }
    /**
     * Get the result URL of the job. This method will make a request to the API to get signed URL.
     * IMPORTANT: URL expires after 30 minutes, so make sure to download the image as soon as possible.
     */
    getResultUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.data.status !== 'completed') {
                throw new Error('Job is not completed yet');
            }
            const url = yield this._api.downloadUrl({
                jobId: this.projectId,
                imageId: this.id,
                type: 'complete'
            });
            this._update({ resultUrl: url });
            return url;
        });
    }
    /**
     * Whether the image is NSFW or not. Only makes sense if job is completed.
     * If NSFW filter is disabled, this property will always be false.
     * If NSFW filter is enabled and the image is NSFW, image will not be available for download.
     */
    get isNSFW() {
        return !!this.data.isNSFW;
    }
    /**
     * Name of the worker that is processing this job.
     */
    get workerName() {
        return this.data.workerName;
    }
    /**
     * Syncs the job data with the data received from the REST API.
     * @internal
     * @param data
     */
    _syncWithRestData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const delta = {
                step: data.performedSteps,
                workerName: data.worker.name,
                seed: data.seedUsed,
                isNSFW: data.triggeredNSFWFilter
            };
            if (JOB_STATUS_MAP[data.status]) {
                delta.status = JOB_STATUS_MAP[data.status];
            }
            if (!this.data.resultUrl && delta.status === 'completed' && !data.triggeredNSFWFilter) {
                try {
                    delta.resultUrl = yield this._api.downloadUrl({
                        jobId: this.projectId,
                        imageId: this.id,
                        type: 'complete'
                    });
                }
                catch (error) {
                    this._logger.error(error);
                }
            }
            this._update(delta);
        });
    }
    handleUpdated(keys) {
        if (keys.includes('step') || keys.includes('stepCount')) {
            this.emit('progress', this.progress);
        }
        if (keys.includes('status') && this.status === 'completed') {
            this.emit('completed', this.resultUrl);
        }
        if (keys.includes('status') && this.status === 'failed') {
            this.emit('failed', this.data.error);
        }
    }
    handleEnhancementUpdate() {
        this.emit('updated', ['enhancedImage']);
    }
    getResultData() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasResultImage) {
                throw new Error('No result image available');
            }
            const url = yield this.getResultUrl();
            const response = yield fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.statusText}`);
            }
            return response.blob();
        });
    }
    /**
     * Enhance the image using the Flux model. This method will create a new project with the
     * enhancement parameters and use the result image of the current job as the starting image.
     * @param strength - how much freedom the model has to change the image.
     * @param overrides - optional parameters to override original prompt, style or token type.
     */
    enhance(strength_1) {
        return __awaiter(this, arguments, void 0, function* (strength, overrides = {}) {
            if (this.status !== 'completed') {
                throw new Error('Job is not completed yet');
            }
            if (this.isNSFW) {
                throw new Error('Job did not pass NSFW filter');
            }
            if (this._enhancementProject) {
                this._enhancementProject.off('updated', this.handleEnhancementUpdate);
                this._enhancementProject = null;
            }
            const imageData = yield this.getResultData();
            const project = yield this._api.create(Object.assign(Object.assign({}, exports.enhancementDefaults), { positivePrompt: overrides.positivePrompt || this._project.params.positivePrompt, stylePrompt: overrides.stylePrompt || this._project.params.stylePrompt, tokenType: overrides.tokenType || this._project.params.tokenType, seed: this.seed || this._project.params.seed, startingImage: imageData, startingImageStrength: 1 - (0, utils_1.getEnhacementStrength)(strength), sizePreset: this._project.params.sizePreset }));
            this._enhancementProject = project;
            this._enhancementProject.on('updated', this.handleEnhancementUpdate);
            const images = yield project.waitForCompletion();
            return images[0];
        });
    }
}
exports.default = Job;
//# sourceMappingURL=Job.js.map