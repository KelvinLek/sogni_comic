"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ApiGroup_1 = __importDefault(require("../ApiGroup"));
const Project_1 = __importDefault(require("./Project"));
const createJobRequestMessage_1 = __importDefault(require("./createJobRequestMessage"));
const ApiClient_1 = require("../ApiClient");
const getUUID_1 = __importDefault(require("../lib/getUUID"));
const Cache_1 = __importDefault(require("../lib/Cache"));
const Job_1 = require("./Job");
const utils_1 = require("./utils");
const sizePresetCache = new Cache_1.default(10 * 60 * 1000);
const GARBAGE_COLLECT_TIMEOUT = 30000;
const MODELS_REFRESH_INTERVAL = 1000 * 60 * 60 * 24; // 24 hours
function mapErrorCodes(code) {
    switch (code) {
        case 'serverRestarting':
            return 5001;
        case 'workerDisconnected':
            return 5002;
        case 'jobTimedOut':
            return 5003;
        case 'artistCanceled':
            return 5004;
        case 'workerCancelled':
            return 5005;
        default:
            return 5000;
    }
}
class ProjectsApi extends ApiGroup_1.default {
    get availableModels() {
        return this._availableModels;
    }
    constructor(config) {
        super(config);
        this._availableModels = [];
        this.projects = [];
        this._supportedModels = {
            data: null,
            updatedAt: new Date(0)
        };
        // Listen to server events and emit them as project and job events
        this.client.socket.on('changeNetwork', this.handleChangeNetwork.bind(this));
        this.client.socket.on('swarmModels', this.handleSwarmModels.bind(this));
        this.client.socket.on('jobState', this.handleJobState.bind(this));
        this.client.socket.on('jobProgress', this.handleJobProgress.bind(this));
        this.client.socket.on('jobError', this.handleJobError.bind(this));
        this.client.socket.on('jobResult', this.handleJobResult.bind(this));
        // Listen to the server disconnect event
        this.client.on('disconnected', this.handleServerDisconnected.bind(this));
        // Listen to project and job events and update project and job instances
        this.on('project', this.handleProjectEvent.bind(this));
        this.on('job', this.handleJobEvent.bind(this));
    }
    handleChangeNetwork() {
        this._availableModels = [];
        this.emit('availableModels', this._availableModels);
    }
    handleSwarmModels(data) {
        return __awaiter(this, void 0, void 0, function* () {
            let models = [];
            try {
                models = yield this.getSupportedModels();
            }
            catch (e) {
                this.client.logger.error(e);
            }
            const modelIndex = models.reduce((acc, model) => {
                acc[model.id] = model;
                return acc;
            }, {});
            this._availableModels = Object.entries(data).map(([id, workerCount]) => {
                var _a;
                return ({
                    id,
                    name: ((_a = modelIndex[id]) === null || _a === void 0 ? void 0 : _a.name) || id.replace(/-/g, ' '),
                    workerCount
                });
            });
            this.emit('availableModels', this._availableModels);
        });
    }
    handleJobState(data) {
        switch (data.type) {
            case 'queued':
                this.emit('project', {
                    type: 'queued',
                    projectId: data.jobID,
                    queuePosition: data.queuePosition
                });
                return;
            case 'jobCompleted':
                this.emit('project', { type: 'completed', projectId: data.jobID });
                return;
            case 'initiatingModel':
                this.emit('job', {
                    type: 'initiating',
                    projectId: data.jobID,
                    jobId: data.imgID,
                    workerName: data.workerName,
                    positivePrompt: data.positivePrompt,
                    negativePrompt: data.negativePrompt,
                    jobIndex: data.jobIndex
                });
                return;
            case 'jobStarted': {
                this.emit('job', {
                    type: 'started',
                    projectId: data.jobID,
                    jobId: data.imgID,
                    workerName: data.workerName,
                    positivePrompt: data.positivePrompt,
                    negativePrompt: data.negativePrompt,
                    jobIndex: data.jobIndex
                });
                return;
            }
        }
    }
    handleJobProgress(data) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('job', {
                type: 'progress',
                projectId: data.jobID,
                jobId: data.imgID,
                step: data.step,
                stepCount: data.stepCount
            });
            if (data.hasImage) {
                this.downloadUrl({
                    jobId: data.jobID,
                    imageId: data.imgID,
                    type: 'preview'
                }).then((url) => {
                    this.emit('job', {
                        type: 'preview',
                        projectId: data.jobID,
                        jobId: data.imgID,
                        url
                    });
                });
            }
        });
    }
    handleJobResult(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const project = this.projects.find((p) => p.id === data.jobID);
            const passNSFWCheck = !data.triggeredNSFWFilter || !project || project.params.disableNSFWFilter;
            let downloadUrl = null;
            // If NSFW filter is triggered, image will be only available for download if user explicitly
            // disabled the filter for this project
            if (passNSFWCheck && !data.userCanceled) {
                downloadUrl = yield this.downloadUrl({
                    jobId: data.jobID,
                    imageId: data.imgID,
                    type: 'complete'
                });
            }
            this.emit('job', {
                type: 'completed',
                projectId: data.jobID,
                jobId: data.imgID,
                steps: data.performedStepCount,
                seed: Number(data.lastSeed),
                resultUrl: downloadUrl,
                isNSFW: data.triggeredNSFWFilter,
                userCanceled: data.userCanceled
            });
        });
    }
    handleJobError(data) {
        var _a;
        const errorCode = Number(data.error);
        let error;
        if (!isNaN(errorCode)) {
            error = {
                code: errorCode,
                message: data.error_message
            };
        }
        else {
            error = {
                code: mapErrorCodes(data.error),
                originalCode: (_a = data.error) === null || _a === void 0 ? void 0 : _a.toString(),
                message: data.error_message
            };
        }
        if (!data.imgID) {
            this.emit('project', {
                type: 'error',
                projectId: data.jobID,
                error
            });
            return;
        }
        this.emit('job', {
            type: 'error',
            projectId: data.jobID,
            jobId: data.imgID,
            error: error
        });
    }
    handleProjectEvent(event) {
        let project = this.projects.find((p) => p.id === event.projectId);
        if (!project) {
            return;
        }
        switch (event.type) {
            case 'queued':
                project._update({
                    status: 'queued',
                    queuePosition: event.queuePosition
                });
                break;
            case 'completed':
                project._update({
                    status: 'completed'
                });
                break;
            case 'error':
                project._update({
                    status: 'failed',
                    error: event.error
                });
        }
        if (project.finished) {
            // Sync project data with the server and remove it from the list after some time
            project._syncToServer().catch((e) => {
                this.client.logger.error(e);
            });
            setTimeout(() => {
                this.projects = this.projects.filter((p) => !p.finished);
            }, GARBAGE_COLLECT_TIMEOUT);
        }
    }
    handleJobEvent(event) {
        let project = this.projects.find((p) => p.id === event.projectId);
        if (!project) {
            return;
        }
        let job = project.job(event.jobId);
        if (!job) {
            job = project._addJob({
                id: event.jobId,
                projectId: event.projectId,
                status: 'pending',
                step: 0,
                stepCount: project.params.steps
            });
        }
        switch (event.type) {
            case 'initiating':
                // positivePrompt and negativePrompt are only received if a Dynamic Prompt was used for the project creating a different prompt for each job
                job._update({
                    status: 'initiating',
                    workerName: event.workerName,
                    positivePrompt: event.positivePrompt,
                    negativePrompt: event.negativePrompt,
                    jobIndex: event.jobIndex
                });
                break;
            case 'started':
                // positivePrompt and negativePrompt are only received if a Dynamic Prompt was used for the project creating a different prompt for each job
                job._update({
                    status: 'processing',
                    workerName: event.workerName,
                    positivePrompt: event.positivePrompt,
                    negativePrompt: event.negativePrompt,
                    jobIndex: event.jobIndex
                });
                break;
            case 'progress':
                job._update({
                    status: 'processing',
                    // Jus in case event comes out of order
                    step: Math.max(event.step, job.step),
                    stepCount: event.stepCount
                });
                if (project.status !== 'processing') {
                    project._update({ status: 'processing' });
                }
                break;
            case 'preview':
                job._update({ previewUrl: event.url });
                break;
            case 'completed': {
                job._update({
                    status: event.userCanceled ? 'canceled' : 'completed',
                    step: event.steps,
                    seed: event.seed,
                    resultUrl: event.resultUrl,
                    isNSFW: event.isNSFW,
                    userCanceled: event.userCanceled
                });
                break;
            }
            case 'error':
                job._update({ status: 'failed', error: event.error });
                break;
        }
    }
    handleServerDisconnected() {
        this._availableModels = [];
        this.emit('availableModels', this._availableModels);
        this.projects.forEach((p) => {
            p._update({ status: 'failed', error: { code: 0, message: 'Server disconnected' } });
        });
    }
    /**
     * Wait for available models to be received from the network. Useful for scripts that need to
     * run after the models are loaded.
     * @param timeout - timeout in milliseconds until the promise is rejected
     */
    waitForModels(timeout = 10000) {
        if (this._availableModels.length) {
            return Promise.resolve(this._availableModels);
        }
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error('Timeout waiting for models'));
            }, timeout);
            this.once('availableModels', (models) => {
                clearTimeout(timeoutId);
                if (models.length) {
                    resolve(models);
                }
                else {
                    reject(new Error('No models available'));
                }
            });
        });
    }
    /**
     * Send new project request to the network. Returns project instance which can be used to track
     * progress and get resulting images.
     * @param data
     */
    create(data) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const project = new Project_1.default(Object.assign({}, data), { api: this, logger: this.client.logger });
            if (data.startingImage && data.startingImage !== true) {
                yield this.uploadGuideImage(project.id, data.startingImage);
            }
            if (((_a = data.controlNet) === null || _a === void 0 ? void 0 : _a.image) && data.controlNet.image !== true) {
                yield this.uploadCNImage(project.id, data.controlNet.image);
            }
            const request = (0, createJobRequestMessage_1.default)(project.id, data);
            yield this.client.socket.send('jobRequest', request);
            this.projects.push(project);
            return project;
        });
    }
    /**
     * Get project by id, this API returns project data from the server only if the project is
     * completed or failed. If the project is still processing, it will throw 404 error.
     * @internal
     * @param projectId
     */
    get(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.rest.get(`/v1/projects/${projectId}`);
            return data.project;
        });
    }
    /**
     * Cancel project by id. This will cancel all jobs in the project and mark project as canceled.
     * Client may still receive job events for the canceled jobs as it takes some time, but they will
     * be ignored
     * @param projectId
     **/
    cancel(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.socket.send('jobError', {
                jobID: projectId,
                error: 'artistCanceled',
                error_message: 'artistCanceled',
                isFromWorker: false
            });
            const project = this.projects.find((p) => p.id === projectId);
            if (!project) {
                return;
            }
            // Remove project from the list to stop tracking it
            this.projects = this.projects.filter((p) => p.id !== projectId);
            // Cancel all jobs in the project
            project.jobs.forEach((job) => {
                if (!job.finished) {
                    job._update({ status: 'canceled' });
                }
            });
            // If project is still in processing, mark it as canceled
            if (!project.finished) {
                project._update({ status: 'canceled' });
            }
        });
    }
    uploadGuideImage(projectId, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const imageId = (0, getUUID_1.default)();
            const presignedUrl = yield this.uploadUrl({
                imageId: imageId,
                jobId: projectId,
                type: 'startingImage'
            });
            const res = yield fetch(presignedUrl, {
                method: 'PUT',
                body: file
            });
            if (!res.ok) {
                throw new ApiClient_1.ApiError(res.status, {
                    status: 'error',
                    errorCode: 0,
                    message: 'Failed to upload guide image'
                });
            }
            return imageId;
        });
    }
    uploadCNImage(projectId, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const imageId = (0, getUUID_1.default)();
            const presignedUrl = yield this.uploadUrl({
                imageId: imageId,
                jobId: projectId,
                type: 'cnImage'
            });
            const res = yield fetch(presignedUrl, {
                method: 'PUT',
                body: file
            });
            if (!res.ok) {
                throw new ApiClient_1.ApiError(res.status, {
                    status: 'error',
                    errorCode: 0,
                    message: 'Failed to upload ControlNet image'
                });
            }
            return imageId;
        });
    }
    /**
     * Estimate project cost
     */
    estimateCost(_a) {
        return __awaiter(this, arguments, void 0, function* ({ network, tokenType, model, imageCount, stepCount, previewCount, cnEnabled, startingImageStrength, width, height, sizePreset }) {
            const pathParams = [
                tokenType || 'sogni',
                network,
                model,
                imageCount,
                stepCount,
                previewCount,
                cnEnabled ? 1 : 0,
                startingImageStrength ? 1 - startingImageStrength : 0
            ];
            if (sizePreset) {
                const presets = yield this.getSizePresets(network, model);
                const preset = presets.find((p) => p.id === sizePreset);
                if (!preset) {
                    throw new Error('Invalid size preset');
                }
                pathParams.push(preset.width, preset.height);
            }
            else if (width && height) {
                pathParams.push(width, height);
            }
            const r = yield this.client.socket.get(`/api/v2/job/estimate/${pathParams.join('/')}`);
            return {
                token: r.quote.project.costInToken,
                usd: r.quote.project.costInUSD
            };
        });
    }
    estimateEnhancementCost(strength_1) {
        return __awaiter(this, arguments, void 0, function* (strength, tokenType = 'sogni') {
            return this.estimateCost({
                network: Job_1.enhancementDefaults.network,
                tokenType,
                model: Job_1.enhancementDefaults.modelId,
                imageCount: 1,
                stepCount: Job_1.enhancementDefaults.steps,
                previewCount: 0,
                cnEnabled: false,
                startingImageStrength: (0, utils_1.getEnhacementStrength)(strength)
            });
        });
    }
    /**
     * Get upload URL for image
     * @internal
     * @param params
     */
    uploadUrl(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.client.rest.get(`/v1/image/uploadUrl`, params);
            return r.data.uploadUrl;
        });
    }
    /**
     * Get download URL for image
     * @internal
     * @param params
     */
    downloadUrl(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.client.rest.get(`/v1/image/downloadUrl`, params);
            return r.data.downloadUrl;
        });
    }
    getSupportedModels() {
        return __awaiter(this, arguments, void 0, function* (forceRefresh = false) {
            if (this._supportedModels.data &&
                !forceRefresh &&
                Date.now() - this._supportedModels.updatedAt.getTime() < MODELS_REFRESH_INTERVAL) {
                return this._supportedModels.data;
            }
            const models = yield this.client.socket.get(`/api/v1/models/list`);
            this._supportedModels = { data: models, updatedAt: new Date() };
            return models;
        });
    }
    /**
     * Get supported size presets for the model and network. Size presets are cached for 10 minutes.
     *
     * @example
     * ```ts
     * const presets = await client.projects.getSizePresets('fast', 'flux1-schnell-fp8');
     * console.log(presets);
     * ```
     *
     * @param network - 'fast' or 'relaxed'
     * @param modelId - model id (e.g. 'flux1-schnell-fp8')
     * @param forceRefresh - force refresh cache
     * @returns {Promise<{
     *   label: string;
     *   id: string;
     *   width: number;
     *   height: number;
     *   ratio: string;
     *   aspect: string;
     * }[]>}
     */
    getSizePresets(network_1, modelId_1) {
        return __awaiter(this, arguments, void 0, function* (network, modelId, forceRefresh = false) {
            const key = `${network}-${modelId}`;
            const cached = sizePresetCache.read(key);
            if (cached && !forceRefresh) {
                return cached;
            }
            const data = yield this.client.socket.get(`/api/v1/size-presets/network/${network}/model/${modelId}`);
            sizePresetCache.write(key, data);
            return data;
        });
    }
    /**
     * Get available models and their worker counts. Normally, you would get list once you connect
     * to the server, but you can also call this method to get the list of available models manually.
     * @param network
     */
    getAvailableModels(network) {
        return __awaiter(this, void 0, void 0, function* () {
            const workersByModelSid = yield this.client.socket.get(`/api/v1/status/network/${network}/models`);
            const supportedModels = yield this.getSupportedModels();
            return Object.entries(workersByModelSid).map(([sid, workerCount]) => {
                const SID = Number(sid);
                const model = supportedModels.find((m) => m.SID === SID);
                return {
                    id: (model === null || model === void 0 ? void 0 : model.id) || sid,
                    name: (model === null || model === void 0 ? void 0 : model.name) || sid.replace(/-/g, ' '),
                    workerCount
                };
            });
        });
    }
}
exports.default = ProjectsApi;
//# sourceMappingURL=index.js.map