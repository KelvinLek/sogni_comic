"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const ApiClient_1 = require("../ApiClient");
const isNodejs_1 = __importDefault(require("./isNodejs"));
const js_cookie_1 = __importDefault(require("js-cookie"));
const TypedEventEmitter_1 = __importDefault(require("./TypedEventEmitter"));
class AuthManager extends TypedEventEmitter_1.default {
    constructor(baseUrl, logger) {
        super();
        this._tokenExpiresAt = new Date(0);
        this._refreshTokenExpiresAt = new Date(0);
        this._logger = logger;
        this._baseUrl = baseUrl;
    }
    get refreshToken() {
        return this._refreshToken;
    }
    get walletAddress() {
        return this._walletAddress;
    }
    get isAuthenticated() {
        return !!this._refreshToken && this._refreshTokenExpiresAt > new Date();
    }
    _updateCookies() {
        if (isNodejs_1.default) {
            return;
        }
        const token = this._token;
        if (token) {
            js_cookie_1.default.set('authorization', token, {
                domain: '.sogni.ai',
                expires: 1
            });
        }
        else {
            js_cookie_1.default.remove('authorization', {
                domain: '.sogni.ai'
            });
        }
    }
    setTokens(_a) {
        return __awaiter(this, arguments, void 0, function* ({ refreshToken, token }) {
            if (token) {
                this._updateTokens({ token, refreshToken });
                return;
            }
            this._refreshToken = refreshToken;
            const { expiresAt: refreshExpiresAt } = (0, utils_1.decodeRefreshToken)(refreshToken);
            this._refreshTokenExpiresAt = refreshExpiresAt;
            yield this.renewToken();
        });
    }
    getToken() {
        return __awaiter(this, void 0, void 0, function* () {
            //If there is a token, and it is not expired, return it
            if (this._token && this._tokenExpiresAt > new Date()) {
                return this._token;
            }
            //If there is no refresh token, return undefined, to make unauthorized requests
            if (!this._refreshToken) {
                return;
            }
            //If there is a refresh token, try to renew the token
            return this.renewToken();
        });
    }
    renewToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._renewTokenPromise) {
                return this._renewTokenPromise;
            }
            this._renewTokenPromise = this._renewToken();
            this._renewTokenPromise.finally(() => {
                this._renewTokenPromise = undefined;
            });
            return this._renewTokenPromise;
        });
    }
    clear() {
        // Prevent duplicate events
        if (!this._token && !this._refreshToken) {
            return;
        }
        this._refreshToken = undefined;
        this._refreshTokenExpiresAt = new Date(0);
        this._token = undefined;
        this._tokenExpiresAt = new Date(0);
        this._walletAddress = undefined;
        this.emit('updated', { token: null, refreshToken: null, walletAddress: null });
    }
    _updateTokens({ token, refreshToken }) {
        // Prevent duplicate events
        if (this._token === token && this._refreshToken === refreshToken) {
            return;
        }
        this._token = token;
        const { expiresAt, walletAddress } = (0, utils_1.decodeToken)(token);
        this._walletAddress = walletAddress;
        this._tokenExpiresAt = expiresAt;
        this._refreshToken = refreshToken;
        const { expiresAt: refreshExpiresAt } = (0, utils_1.decodeRefreshToken)(refreshToken);
        this._refreshTokenExpiresAt = refreshExpiresAt;
        this._updateCookies();
        this.emit('updated', { token, refreshToken, walletAddress });
    }
    _renewToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._refreshTokenExpiresAt < new Date()) {
                throw new Error('Refresh token expired');
            }
            const url = new URL('/v1/account/refresh-token', this._baseUrl).toString();
            const response = yield fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ refreshToken: this._refreshToken })
            });
            let responseData;
            try {
                responseData = yield response.json();
            }
            catch (e) {
                this.emit('refreshFailed', {
                    status: 'error',
                    errorCode: 0,
                    message: 'Failed to parse response'
                });
                this._logger.error('Failed to parse response:', e);
                throw new Error('Failed to parse response');
            }
            if (!response.ok) {
                this.emit('refreshFailed', responseData);
                this.clear();
                throw new ApiClient_1.ApiError(response.status, responseData);
            }
            const { token, refreshToken } = responseData.data;
            this._updateTokens({ token, refreshToken });
            return this._token;
        });
    }
}
exports.default = AuthManager;
//# sourceMappingURL=AuthManager.js.map